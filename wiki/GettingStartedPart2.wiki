#summary Getting started, part two - understanding a simple application

In a [GettingStartedPart1 part one] I described the steps involved in setting up a new Impala project. It's time to spend a little bit of time examining and understanding what we've created. We'll start with the workspace structure.
 
== Workspace structure == 

The workspace we created in part one consists of five Eclipse projects:

  * *main* the main project, which contains the root module as well as master build. scripts
  * *module1* a single sub-module, which contains an implementation of one of the services we define in the root module.
  * *repository* a project which serves purely as a repository for third party dependenciies, including the Impala libraries used by the application.
  * *web* a web project, consisting of web application classes, view templates, web configuration files, etc.
  * *tests* a tests project.

== Main (root module) ==

Every Impala application needs to contain a root module, which will typically be associated with a single Eclipse project, although it is also possible to use multiple Eclipse projects as the root module constituents.

Impala strongly encourages interface based programming.

The main purpose of the root module is to define interfaces. In Java terms, the interface is implemented simply using a Java interface. There is also a Spring angle to interfaces, as we'll see. Beans in the root module will typically be _interface_ beans.

=== The Java interface definition ===

The quick starter produces a simple _Hello World_ style application. The appropriate interface is called `MessageService`, which, without wishing to jump the gun, has an implementation which returns "Hello World".

{{{
package interfaces;

public interface MessageService {

	public String getMessage();
	
}
}}}

=== The Spring config file ===

One of the fundamental principles of Impala is the idea of separating interface vs implementation. In the case of Spring beans, we want individual beans to be reusable across modules without different modules having to be aware of the implementations that sit behind the beans that they depend on.

So how do we express Spring interface beans in Impala. You probably guessed it - using proxies.

Here's the bean definition for the `messageService` bean.

{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       
	   xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">
	
 <bean id="messageService" class="org.impalaframework.spring.module.ContributionProxyFactoryBean">
	 <property name = "proxyInterfaces" value = "interfaces.MessageService"/>
 </bean>
	
</beans>
}}}

This is contained in the file _spring/parent-context.xml_ in the _main_ project. The bean is defined via the `ContributionProxyFactoryBean` class. Note that the proxy interfaces are defined as properties.

You're probably wondering why the name `ContributionProxyFactoryBean`. The name is because the implementations are not defined in the root module (technically they could be, although it probably wouldn't be good practice to), but are instead effectively contributed via additions to the Impala service registry.

== Module implementation ==

===`MessageService` implementation ===

As the previous discussion has suggested, the implementation for our `MessageService` comes from one of the modules, specifically _module1_.  Our implementation class is trivially simple, defined in the source folder _module1/src':

{{{
package classes;

import interfaces.MessageService;

public class MessageServiceImpl implements MessageService {

	private String message;
	
	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

}
}}}

As you can imagine, the value for the message to be produced via the `getMessage()` call is injected via a Spring configuration file. Here's our Spring configuration, contained in the file _module1/spring/module1-context.xml_.

{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">

    <bean class = "org.impalaframework.spring.module.ModuleContributionPostProcessor"/>

	<bean id="messageService" class="classes.MessageServiceImpl">
		<property name = "message" value = "Hello World!"/>
	</bean>

</beans>
}}}

== Integration tests ==

=== The example test ===

Impala has a heavy focus on making it easy to practice Test Driven Development (TDD) when working with Spring applications. The pain point in this area tends to be integration tests, for a number of reasons. Integration tests are more complicated that unit tests, because they involve more dependencies. Separating out the dependencies required for the test from those which are not can be hard at times. Also, because integration tests are slower to run, slow develop/deploy/test cycle times can be an obstacle to productivity.

Apart from the modules and their dynamic reloading capability, an important part of Impala's solution in this area is the integration testing support, in particular through the interactive test runner.

Below we have an integration test for our `MessageService` implementation.

{{{
package test;

import interfaces.MessageService;

import org.impalaframework.facade.Impala;
import org.impalaframework.module.builder.SimpleModuleDefinitionSource;
import org.impalaframework.module.definition.RootModuleDefinition;
import org.impalaframework.testrun.InteractiveTestRunner;

import test.BaseIntegrationTest;

public class MessageIntegrationTest extends BaseIntegrationTest {

	public static void main(String[] args) {
		InteractiveTestRunner.run(MessageIntegrationTest.class);
	}

	public void testIntegration() {
		MessageService service = Impala.getBean("messageService", MessageService.class);
		System.out.println(service.getMessage());
	}

	public RootModuleDefinition getModuleDefinition() {
		return new SimpleModuleDefinitionSource("wineorder",
				new String[] { "parent-context.xml" }, 
                                new String[] {"module1"}).getModuleDefinition();
	}

}
}}}

This integration test lives in the _main_ module in the _tests_ source folder. The fact that the test can live in the _main_ module is important, when we consider that the implementation for `MessageService` is in the module _module1_. It tests the behaviour of the `MessageService` through it's interface, rather than it's implementation. 

Let's consider some aspects of the test implementation. 

First, it extends `BaseIntegrationTest`, which simply extends JUnit `TestCase` and has an implementation of the JUnit `setUp()` method, which we will see in a moment. 

The next thing to notice is the main method. The main method is used to start the interactive test runner. 

The test is pretty straightforward. The pertinent bit is the use of the convenience method `Impala.getBean(beanName, type)` to retrieve a reference to `messageService`. This call effectively obtains the named bean from the Spring `ApplicationContext` associated with the root module.

You're probably wondering at this point how `Impala` gets to find out about the module constituents and hierarchy in the first place. To allow this to happen, we need to provide an implementation of `ModuleDefinitionSource`, which we do so in the final method shown in `MessageIntegrationTest`. 

To complete the puzzle, we need to take a look at the superclass, `BaseIntegrationTest`, which has the following form:

{{{
public abstract class BaseIntegrationTest extends TestCase 
	implements ModuleDefinitionSource {
	
	@Override
	protected void setUp() throws Exception {
		super.setUp();
		Impala.init(this);
	}
}
}}}

The method `Impala.init()` takes a parameter of type `ModuleDefintionSource`, hence the use of `this`. So what happens when `init()` is called? Impala effectively takes a look at the module hierarchy definition supplied via the `ModuleDefinitionSource` implementation. Impala integration tests typically themselves implement the interface `ModuleDefinitionSource`. It then compares it with the currently loaded module set. It will then make adjustments as appropriate. For example, it it encounters a module which has not been loaded, it will load this module. If it encounters one whose definition varies from the loaded module, the loaded module will be unloaded, and a new module loaded from the definition supplied in the `ModuleDefinitionSource` implementation.

This mechanism allows modules to be loaded incrementally over a test run, and only unloaded when required. This helps dramatically speed up the time taken to run a suite of integration tests compared to situations in which the full Spring context is loaded for each test.

It is also possible to define integration tests which refer directly to the implementation classes. An example is the `ProjectMessageIntegrationTest`, defined in _module1/tests_, whose `testIntegration` method has the following form:

{{{
	public void testIntegration() {
		MessageService service = Impala.getModuleBean("module1", "messageService", MessageService.class);
		System.out.println(service.getMessage());
	}
}}}


== Repository project ==

http://impala.googlecode.com/svn/wiki/images/getting_started_workspace.jpg

== Tests project ==

{{{
public class AllTests extends TestCase {
	public static Test suite() {
		TestSuite suite = new TestSuite();
		suite.addTestSuite(MessageIntegrationTest.class);
		suite.addTestSuite(ProjectMessageIntegrationTest.class);
		return suite;
	}
}
}}}

== Running the standalone interactive client ==

Use Eclipse to find the !JUnit test class `MessageIntegrationTest`. Again, run this as a Java application, and execute tests, reload modules etc, using the interactive test runner. Here's some example output:

{{{
log4j:WARN No appenders could be found for logger (org.springframework.context.support.ClassPathXmlApplicationContext).
log4j:WARN Please initialize the log4j system properly.
Test class set to test.MessageIntegrationTest
Unable to load module corresponding with directory name [not set]
Starting inactivity checker with maximum inactivity of 600 seconds
--------------------

Please enter your command text
>test
No module loaded for current directory: main
Running test `testIntegration`
.Hello World!

Time: 0.055

OK (1 test)


Please enter your command text
>reload
Module 'root-module' loaded in 0.096 seconds
Used memory: 1.5MB
Max available memory: 63.6MB


Please enter your command text
>module module
Module 'module' loaded in 0.035 seconds
Used memory: 2.1MB
Max available memory: 63.6MB


Please enter your command text
>t
No module loaded for current directory: main
Running test testIntegration
.Hello World!

Time: 0.012

OK (1 test)
}}}

== Run the suite of tests ==

Any of the JUnit integration tests can be run as a regular unit test in Eclipse, with green bar and all. From the tests project, find the class `AllTests`. This contains a suite of tests covering all the tests in the project. Run this as a regular unit test, and you will see the following:

http://impala.googlecode.com/svn/wiki/images/scaffold_alltests.jpg