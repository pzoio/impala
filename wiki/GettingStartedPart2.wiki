#summary Getting started, part two - understanding a simple application

In a [GettingStartedPart1 part one] I described the steps involved in setting up a new Impala project. It's time to spend a little bit of time examining and understanding what we've created. We'll start with the workspace structure.
 
== Workspace structure == 

The workspace we created in part one consists of five Eclipse projects:

  * *main* the main project, which contains the root module as well as master build. scripts
  * *module1* a single sub-module, which contains an implementation of one of the services we define in the root module.
  * *repository* a project which serves purely as a repository for third party dependenciies, including the Impala libraries used by the application.
  * *web* a web project, consisting of web application classes, view templates, web configuration files, etc.
  * *tests* a tests project.

== Main (root module) ==

Every Impala application needs to contain a root module, which will typically be associated with a single Eclipse project, although it is also possible to use multiple Eclipse projects as the root module constituents.

Impala strongly encourages interface based programming.

The main purpose of the root module is to define interfaces. In Java terms, the interface is implemented simply using a Java interface. There is also a Spring angle to interfaces, as we'll see. Beans in the root module will typically be _interface_ beans.

=== The Java interface definition ===

The quick starter produces a simple _Hello World_ style application. The appropriate interface is called `MessageService`, which, without wishing to jump the gun, has an implementation which returns "Hello World".

{{{
package interfaces;

public interface MessageService {

	public String getMessage();
	
}
}}}

=== The Spring config file ===

One of the fundamental principles of Impala is the idea of separating interface vs implementation. In the case of Spring beans, we want individual beans to be reusable across modules without different modules having to be aware of the implementations that sit behind the beans that they depend on.

So how do we express Spring interface beans in Impala. You probably guessed it - using proxies.

Here's the bean definition for the `messageService` bean.

{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       
	   xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">
	
 <bean id="messageService" class="org.impalaframework.spring.module.ContributionProxyFactoryBean">
	 <property name = "proxyInterfaces" value = "interfaces.MessageService"/>
 </bean>
	
</beans>
}}}

This is contained in the file _spring/parent-context.xml_ in the _main_ project. The bean is defined via the `ContributionProxyFactoryBean` class. Note that the proxy interfaces are defined as properties.

You're probably wondering why the name `ContributionProxyFactoryBean`. The name is because the implementations are not defined in the root module (technically they could be, although it probably wouldn't be good practice to), but are instead effectively contributed via additions to the Impala service registry.

== Module impelementation ===

`MessageService` implementation

{{{
package classes;

import interfaces.MessageService;

public class MessageServiceImpl implements MessageService {

	private String message;
	
	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

}
}}}

Spring config file

{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">

    <bean class = "org.impalaframework.spring.module.ModuleContributionPostProcessor"/>

	<bean id="messageService" class="classes.MessageServiceImpl">
		<property name = "message" value = "Hello World!"/>
	</bean>

</beans>
}}}

=== The example test ===

{{{
package test;

import interfaces.MessageService;

import org.impalaframework.facade.Impala;
import org.impalaframework.module.builder.SimpleModuleDefinitionSource;
import org.impalaframework.module.definition.RootModuleDefinition;
import org.impalaframework.testrun.InteractiveTestRunner;

import test.BaseIntegrationTest;

public class MessageIntegrationTest extends BaseIntegrationTest {

	public static void main(String[] args) {
		InteractiveTestRunner.run(MessageIntegrationTest.class);
	}

	public void testIntegration() {
		MessageService service = Impala.getBean("messageService", MessageService.class);
		System.out.println(service.getMessage());
	}

	public RootModuleDefinition getModuleDefinition() {
		return new SimpleModuleDefinitionSource("wineorder",
				new String[] { "parent-context.xml" }, 
                                new String[] {"module1"}).getModuleDefinition();
	}

}
}}}


== Repository project ==

http://impala.googlecode.com/svn/wiki/images/getting_started_workspace.jpg

== Tests project ==

{{{
public class AllTests extends TestCase {
	public static Test suite() {
		TestSuite suite = new TestSuite();
		suite.addTestSuite(MessageIntegrationTest.class);
		suite.addTestSuite(ProjectMessageIntegrationTest.class);
		return suite;
	}
}
}}}

== Running the standalone interactive client ==

Use Eclipse to find the !JUnit test class `MessageIntegrationTest`. Again, run this as a Java application, and execute tests, reload modules etc, using the interactive test runner. Here's some example output:

{{{
log4j:WARN No appenders could be found for logger (org.springframework.context.support.ClassPathXmlApplicationContext).
log4j:WARN Please initialize the log4j system properly.
Test class set to test.MessageIntegrationTest
Unable to load module corresponding with directory name [not set]
Starting inactivity checker with maximum inactivity of 600 seconds
--------------------

Please enter your command text
>test
No module loaded for current directory: main
Running test `testIntegration`
.Hello World!

Time: 0.055

OK (1 test)


Please enter your command text
>reload
Module 'root-module' loaded in 0.096 seconds
Used memory: 1.5MB
Max available memory: 63.6MB


Please enter your command text
>module module
Module 'module' loaded in 0.035 seconds
Used memory: 2.1MB
Max available memory: 63.6MB


Please enter your command text
>t
No module loaded for current directory: main
Running test testIntegration
.Hello World!

Time: 0.012

OK (1 test)
}}}

== Run the suite of tests ==

Any of the JUnit integration tests can be run as a regular unit test in Eclipse, with green bar and all. From the tests project, find the class `AllTests`. This contains a suite of tests covering all the tests in the project. Run this as a regular unit test, and you will see the following:

http://impala.googlecode.com/svn/wiki/images/scaffold_alltests.jpg