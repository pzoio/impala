#summary Getting started, part two - understanding a simple application

In a [GettingStartedPart1 part one] I described the steps involved in setting up a new Impala project. It's time to spend a little bit of time examining and understanding what we've created. We'll start with the workspace structure.

== Main or root module ==

Every Impala application needs to contain a root module, which will typically be associated with a single Eclipse project, although it is also possible to use multiple Eclipse projects as the root module constituents.

Impala strongly encourages _interface based programming_. The main purpose of the root module is to define interfaces. In Java terms, the interface is implemented simply using a Java interface. There is also a Spring angle to interfaces, as we'll see. Beans in the root module will typically be _interface_ beans.

=== The Java interface definition ===

The quick starter produces a simple _Hello World_ style application. The appropriate interface is called `MessageService`, which, without wishing to jump the gun, has an implementation which returns "Hello World".

{{{
package interfaces;

public interface MessageService {

	public String getMessage();
	
}
}}}

=== The Spring config file ===

One of the fundamental principles of Impala is the idea of separating interface vs implementation. In the case of Spring beans, we want individual beans to be reusable across modules without different modules having to be aware of the implementations that sit behind the beans that they depend on.

So how do we express Spring interface beans in Impala. You probably guessed it - using proxies.

Here's the bean definition for the `messageService` bean.

{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       
	   xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">
	
 <bean id="messageService" class="org.impalaframework.spring.module.ContributionProxyFactoryBean">
	 <property name = "proxyInterfaces" value = "interfaces.MessageService"/>
 </bean>
	
</beans>
}}}

This is contained in the file _spring/parent-context.xml_ in the _main_ project. The bean is defined via the `ContributionProxyFactoryBean` class. Note that the proxy interfaces are defined as properties.

You're probably wondering why the name `ContributionProxyFactoryBean`. The name is because the implementations are not defined in the root module (technically they could be, although it probably wouldn't be good practice to), but are instead effectively contributed via additions to the Impala service registry.

== Module implementation ==

While the focus of the root module is primarily on providing a set of interface beans and a home for Java interfaces and shared/domain classes used in the application, sub-modules are typically more implementation focussed. 

In our simple generated application, the implementation of our `MessageService` bean comes from the module _module1_. Before _module1_ has been loaded, it would be possible for clients to obtain a reference to the `MessageService` bean via the Java interface. However, actually calling methods on this bean would result in a `NoServiceException` - that is, until _module1_ has been loaded.

Note that modules form a hierarchy. For example, we could extend our sample application by creating new modules _module1A_ and _module1B_ as submodules of _module1_. In situations where deeply nested hierarchies of modules exist, it is possible for certain modules to straddle the interface/implementation boundary. However, in general, I'd recommend a fairly flat hierarchy of modules to keep things simple where possible.

===`MessageService` implementation ===

Our implementation class for `MessageService` is trivially simple, defined in the source folder _module1/src_:

{{{
package classes;

import interfaces.MessageService;

public class MessageServiceImpl implements MessageService {

	private String message;
	
	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

}
}}}

As you can imagine, the value for the message to be produced via the `getMessage()` call is injected via a Spring configuration file. Here's our Spring configuration, contained in the file _module1/spring/module1-context.xml_.

{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">

    <bean class = "org.impalaframework.spring.module.ModuleContributionPostProcessor"/>

	<bean id="messageService" class="classes.MessageServiceImpl">
		<property name = "message" value = "Hello World!"/>
	</bean>

</beans>
}}}

Of course, we won't see any of this working until we take a look at integration tests.

== Integration tests ==

=== The example test ===

Impala has a heavy focus on making it easy to practice Test Driven Development (TDD) when working with Spring applications. The pain point in this area tends to be integration tests, for a number of reasons. Integration tests are more complicated that unit tests, because they involve more dependencies. Separating out the dependencies required for the test from those which are not can be hard at times. Also, because integration tests are slower to run, slow develop/deploy/test cycle times can be an obstacle to productivity.

Apart from the modules and their dynamic reloading capability, an important part of Impala's solution in this area is the integration testing support, in particular through the interactive test runner.

Below we have an integration test for our `MessageService` implementation.

{{{
package test;

import interfaces.MessageService;

import org.impalaframework.facade.Impala;
import org.impalaframework.module.builder.SimpleModuleDefinitionSource;
import org.impalaframework.module.definition.RootModuleDefinition;
import org.impalaframework.testrun.InteractiveTestRunner;

import test.BaseIntegrationTest;

public class MessageIntegrationTest extends BaseIntegrationTest {

	public static void main(String[] args) {
		InteractiveTestRunner.run(MessageIntegrationTest.class);
	}

	public void testIntegration() {
		MessageService service = Impala.getBean("messageService", MessageService.class);
		System.out.println(service.getMessage());
	}

	public RootModuleDefinition getModuleDefinition() {
		return new SimpleModuleDefinitionSource("wineorder",
				new String[] { "parent-context.xml" }, 
                                new String[] {"module1"}).getModuleDefinition();
	}

}
}}}

This integration test lives in the _main_ module in the _tests_ source folder. The fact that the test can live in the _main_ module is important, when we consider that the implementation for `MessageService` is in the module _module1_. It tests the behaviour of the `MessageService` through it's interface, rather than it's implementation. 

Let's consider some aspects of the test implementation. 

First, it extends `BaseIntegrationTest`, which simply extends JUnit `TestCase` and has an implementation of the JUnit `setUp()` method, which we will see in a moment. 

The next thing to notice is the main method. The main method is used to start the interactive test runner. 

The test is pretty straightforward. The pertinent bit is the use of the convenience method `Impala.getBean(beanName, type)` to retrieve a reference to `messageService`. This call effectively obtains the named bean from the Spring `ApplicationContext` associated with the root module.

You're probably wondering at this point how `Impala` gets to find out about the module constituents and hierarchy in the first place. To allow this to happen, we need to provide an implementation of `ModuleDefinitionSource`, which we do so in the final method shown in `MessageIntegrationTest`. 

To complete the puzzle, we need to take a look at the superclass, `BaseIntegrationTest`, which has the following form:

{{{
public abstract class BaseIntegrationTest extends TestCase 
	implements ModuleDefinitionSource {
	
	@Override
	protected void setUp() throws Exception {
		super.setUp();
		Impala.init(this);
	}
}
}}}

The method `Impala.init()` takes a parameter of type `ModuleDefintionSource`, hence the use of `this`. So what happens when `init()` is called? Impala effectively takes a look at the module hierarchy definition supplied via the `ModuleDefinitionSource` implementation. Impala integration tests typically themselves implement the interface `ModuleDefinitionSource`. It then compares it with the currently loaded module set. It will then make adjustments as appropriate. For example, it it encounters a module which has not been loaded, it will load this module. If it encounters one whose definition varies from the loaded module, the loaded module will be unloaded, and a new module loaded from the definition supplied in the `ModuleDefinitionSource` implementation.

This mechanism allows modules to be loaded incrementally over a test run, and only unloaded when required. This helps dramatically speed up the time taken to run a suite of integration tests compared to situations in which the full Spring context is loaded for each test.

== Module level integration tests ==

The first integration test we described lived in the root module. In this case, it is only possible to refer to root Spring module beans via their Java interfaces. At times, it is also useful to refer in integration tests to implementation beans directly. For example, if you are testing beans which are not exported to the service registry, but are instead part of the internal implementation of a module, this can be helpful.

An example of this is provided in the form of the `ProjectMessageIntegrationTest`, defined in _module1/tests_, whose `testIntegration` method has the following form:

{{{
	public void testIntegration() {
		MessageService service = Impala.getModuleBean("module1", "messageService", MessageService.class);
		System.out.println(service.getMessage());
	}
}}}

Notice that the bean reference is obtained using `Impala.getModuleBean(moduleName, beanName, type)`. This will obtain a reference to the bean implementation, and not a proxy. The restriction, of course, is that these integration tests must be found in the in the relevant module project, or in projects corresponding to sub-modules of the module containing the bean implementation. 

=== Running the standalone interactive client ===

Let's get a bit more dynamic and see what happens when we run the interactive test runner for the !JUnit test class `MessageIntegrationTest`. 

As mentioned, this is a main Java application, which can be used to interactively execute tests, reload modules, etc. Here's some example output:

{{{
log4j:WARN No appenders could be found for logger (org.springframework.context.support.ClassPathXmlApplicationContext).
log4j:WARN Please initialize the log4j system properly.
Test class set to test.MessageIntegrationTest
Unable to load module corresponding with directory name [not set]
Starting inactivity checker with maximum inactivity of 600 seconds
--------------------

Please enter your command text
>test
No module loaded for current directory: main
Running test `testIntegration`
.Hello World!

Time: 0.055

OK (1 test)


Please enter your command text
>reload
Module 'root-module' loaded in 0.096 seconds
Used memory: 1.5MB
Max available memory: 63.6MB


Please enter your command text
>module module
Module 'module' loaded in 0.035 seconds
Used memory: 2.1MB
Max available memory: 63.6MB


Please enter your command text
>t
No module loaded for current directory: main
Running test testIntegration
.Hello World!

Time: 0.012

OK (1 test)
}}}

== Tests project ==

A feature of an Impala workspace is a single _tests_ project. The main purpose of the _tests_ project is to provide a single location from which all test suites can be run. For this reason, by convention, the _tests_ project will include references to all the projects in the workspace which contain tests, as the image below shows:

http://impala.googlecode.com/svn/wiki/images/getting_started_testprops.jpg

The _tests_ project can reference all projects in the workspace, it is the ideal place for defining test suites which can be run across multiple application projects. It should not be used for application code, though. 

{{{
public class AllTests extends TestCase {
	public static Test suite() {
		TestSuite suite = new TestSuite();
		suite.addTestSuite(MessageIntegrationTest.class);
		suite.addTestSuite(ProjectMessageIntegrationTest.class);
		return suite;
	}
}
}}}


== Run the suite of tests ==

Any of the JUnit integration tests can be run as a regular unit test in Eclipse, with green bar and all. From the tests project, find the class `AllTests`. This contains a suite of tests covering all the tests in the project. Run this as a regular unit test, and you will see the following:

http://impala.googlecode.com/svn/wiki/images/scaffold_alltests.jpg