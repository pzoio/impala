#summary Getting started, part two - implementing modules

= Implementing Modules =

In a [GettingStartedPart1 part one] I described the steps involved in setting up a new Impala project. It's time to spend a little bit of time examining and understanding what we've created. We'll start with the workspace structure.

== Implementing the main or root module ==

Every Impala application needs to contain a root module, which will typically be associated with a single Eclipse project, although it is also possible to use multiple Eclipse projects as the root module constituents.

Impala strongly encourages _interface based programming_. The main purpose of the root module is to define interfaces. In Java terms, the interface is implemented simply using a Java interface. There is also a Spring angle to interfaces, as we'll see. Beans in the root module will typically be _interface_ beans.

=== The Java interface definition ===

The quick starter produces a simple _Hello World_ style application. The appropriate interface is called `MessageService`, which, without wishing to jump the gun, has an implementation which returns "Hello World".

{{{
package interfaces;

public interface MessageService {

	public String getMessage();
	
}
}}}

=== The Spring config file ===

One of the fundamental principles of Impala is the idea of separating interface vs implementation. In the case of Spring beans, we want individual beans to be reusable across modules without different modules having to be aware of the implementations that sit behind the beans that they depend on.

So how do we express Spring interface beans in Impala. You probably guessed it - using proxies.

Here's the bean definition for the `messageService` bean.

{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       
	   xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
http://www.springframework.org/schema/tx 
http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">
	
 <bean id="messageService" 
 	class="org.impalaframework.spring.service.proxy.ContributionProxyFactoryBean">
	 <property name = "proxyInterfaces" value = "com.application.main.MessageService"/>
 </bean>
	
</beans>
}}}

This is contained in the file _spring/parent-context.xml_ in the _main_ project. The bean is defined via the `ContributionProxyFactoryBean` class. Note that the proxy interfaces are defined as properties.

You're probably wondering why the name `ContributionProxyFactoryBean`. The name is because the implementations are not defined in the root module (technically they could be, although it probably wouldn't be good practice to), but are instead effectively contributed via additions to the Impala service registry.

=== Module Definition File ===

From 1.0M2, Impala supports the notion of self-contained modules. The idea is that modules themselves have a mechanism for specifying all the information needed to determine their position in the module hierarchy as well as their internal composition. The default location for this information is in a file called module.properties, which will be located in the root of the module's class path. 

The _module.properties_ file for the root module is show below. 

{{{
root-project-names=main
context-locations=parent-context.xml
}}}

This file identifies the Spring context locations for the module, as well as the projects which comprise the root module.

== Implementing a child or sub module ==

While the focus of the root module is primarily on providing a set of interface beans and a home for Java interfaces and shared/domain classes used in the application, sub-modules are typically more implementation focussed. 

In our simple generated application, the implementation of our `MessageService` bean comes from the module _module1_. Before _module1_ has been loaded, it would be possible for clients to obtain a reference to the `MessageService` bean via the Java interface. However, actually calling methods on this bean would result in a `NoServiceException` - that is, until _module1_ has been loaded.

Note that modules form a hierarchy. For example, we could extend our sample application by creating new modules _module1A_ and _module1B_ as submodules of _module1_. In situations where deeply nested hierarchies of modules exist, it is possible for certain modules to straddle the interface/implementation boundary. However, in general, I'd recommend a fairly flat hierarchy of modules to keep things simple where possible.

===`MessageService` implementation ===

Our implementation class for `MessageService` is trivially simple, defined in the source folder _module1/src_:

{{{
package classes;

import interfaces.MessageService;

public class MessageServiceImpl implements MessageService {

	private String message;
	
	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

}
}}}

As you can imagine, the value for the message to be produced via the `getMessage()` call is injected via a Spring configuration file. Here's our Spring configuration, contained in the file _module1/spring/module1-context.xml_.

{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">

    <bean class = "org.impalaframework.spring.module.ModuleContributionPostProcessor"/>

	<bean id="messageService" class="classes.MessageServiceImpl">
		<property name = "message" value = "Hello World!"/>
	</bean>

</beans>
}}}

Finally, we show the _module.properties_ file for the child module.

{{{
parent=main
}}}

It simply identifies the name of the parent module.

Of course, we won't see any of this working until we take a look at integration tests, which we take a look at in [GettingStartedPart3 part three].