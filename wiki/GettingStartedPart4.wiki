#summary Getting started, part three - understanding a web application

== Introduction ==

An important feature of Impala is support for web development. An important requirement of any web development environment is a fast turnaround time between making changes and seeing the displayed in your browser. Impala provides this through it's dynamic module loading capability. Of course, Impala allows for modular web application. Event the web portion of an application can be modularised, by allowing each Servlet to be represented by a separate module. 

Apart from these capabilities, a Spring MVC web application will look no different from a typical web application, since it uses an otherwise identical programming model. 

We'll take a look at how Impala supports web applications next.

== Web project ==

Java web projects are packaged in a well known structure with a web context root directory, a _WEB-INF_ subdirectory, etc. The structure of an Impala web project is shown below:

http://impala.googlecode.com/svn/wiki/images/getting_started_web.jpg

The _context_ folder contains the web context root. The one other difference in terms of file structure is in the _webconfig_ folder, which is also a Java source folder in Eclipse.
The contents of this folder are described in a bit more detail below.

=== web.xml ===

A file which is contained in practically every web application is the _web.xml_ descriptor. This file contains servlets definitions, servlet configuration parameters, filter definitions, and web application life cycle listeners. Lets take a look at the Impala _web.xml_ created for us in [GettingStartedPart1 part one].  

{{{
<web-app>
	
	<display-name>Enter display name here</display-name>

	<description>Enter description here</description>
	
	<context-param>
		<param-name>contextLoaderClassName</param-name>
		<param-value>
                org.impalaframework.web.loader.ExternalModuleContextLoader
                </param-value>
	</context-param>

	<listener>
		<listener-class>
                org.impalaframework.web.loader.ImpalaContextLoaderListener
                </listener-class>
	</listener>
	
	<servlet>
		<servlet-name>web</servlet-name>
                <servlet-class> 
                org.impalaframework.web.servlet.ExternalModuleServlet 
                </servlet-class>
                <load-on-startup>1</load-on-startup>
	</servlet>

	<servlet-mapping>
		<servlet-name>web</servlet-name>
		<url-pattern>*.htm</url-pattern>
	</servlet-mapping>

	<session-config>
		<session-timeout>10</session-timeout>
	</session-config>

	<welcome-file-list>
		<welcome-file>index.jsp</welcome-file>
	</welcome-file-list>
	
</web-app>
}}}

In a plain Spring MVC based web application, the Spring application context which backs the application is loaded via a `ServletContextListener` class called `ContextLoaderListener`. Impala's analogue is `ImpalaContextLoaderListener`, which extends `ContextLoaderListener` to initialise the Impala environment.

The `contextLoaderClassName` specified above is really optional, because `org.impalaframework.web.loader.ExternalModuleContextLoader` is actually the default context loader class. 

Spring MVC applications are usually exposed via the servlet `org.springframework.web.servlet.DispatcherServlet`, or a subclass of this class. Impala provides a number of subclasses of `DispatcherServlet`, but the favoured implementation is `ExternalModuleServlet`.

`ExternalModuleServlet` is so named because it provides a means by which the module definitions which comprise an Impala application are not defined within the _web.xml_ descriptor. In fact, this reflects a deliberate strategy to keep as little configuration in _web.xml_ for the simple reason that _web.xml_ cannot be reloaded without reloading the entire application.

=== Module definitions === 

Recall in [GettingStartedPart2 part two] how integration tests need to provide an implementation of `ModuleDefinitionSource`. `ExternalModuleServlet` also uses a similar mechanism based on an XML-based module specification, defined by default in the file _moduledefinitions.xml_. The _moduledefinitions.xml_ for the generated sample application is shown below:

{{{
<parent>
	<root-project-names>
		<name>main</name>
	</root-project-names>
	<context-locations>
		<context-location>parent-context.xml</context-location>
	</context-locations>
	<modules>
		<module>
			<name>module1</name>
		</module>
		<module>
			<name>web</name>
			<context-locations>
				<context-location>web-context.xml</context-location>
			</context-locations>
			<type>servlet</type>
		</module>
	</modules>
</parent>
}}}

The first two entries are the the name(s) of the projects which comprise the root module, and the names of the application context XML definition files for the root module. Note that unlike child modules (all modules which are not the root modules), the root module may consist of more than one Eclipse project. For any module, the application context XML files defining beans for the module can be explicitly specified.

The `modules` element contains the rest of the module hierarchy. Note that our application consists of only two other modules: `module1` and `web`, corresponding the _module1_ and _web_ project specifically.

One final observation: note the type `servlet` of the module `web`. Each module has a type. The type of the root module is, predicatably, `root`. 

The `web` module is of type `servlet`. This brings us to the link between this file and the _web.xml_. A module of type `servlet` is used to back an Impala servlet, in particular, the servlet with the same name as the name of the module.

=== Spring config file ===

The discussion in the previous section covers some Impala specific aspects of the web application. Next, we cover other elements of the web application, starting with the Spring configuration file for the web module. Spring users will note that the rest of the application is no different from the a typical Spring MVC application, reflecting the fact that Impala does not change the Spring application programming model in any way. 

Here's the Spring configuration file. It consists simply of a `ViewResolver` and `HandlerMapping` bean definitions, as well as a controller bean definition (`MessageController`).  
Recall from the discussion in [GettingStartedPart2 part two] that the sample application is really just a glorified "Hello World" application. The single dependency of the controller is the `MessageService` instance.

{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       
	   xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">

	<bean name="/message.htm" class="web.MessageController">
		<property name = "messageService" ref = "messageService"/>
	</bean>	
	<bean id="handlerMapping" class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/>
	<bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		  <property name="suffix" value=".jsp"/>
	</bean>
</beans>
}}}

We'll see shortly how the controller can be updated on the fly in a web container without having to redeploy the full application.

=== Web controller implementation ===

Next we take a look at the implemention of `MessageController`, which simply has the responsibility of exposing the message provided by the `MessageService` as a web model attribute, and for selecting a view. Based on the `ViewResolver` being used in our Spring web context definition, the view name `test` is translated to a JSP file named `test.jsp`.

{{{
package web;

import java.util.HashMap;

import interfaces.MessageService;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

public class MessageController  implements Controller {
	private MessageService messageService;

	public void setMessageService(MessageService messageService) {
		this.messageService = messageService;
	}

	public ModelAndView handleRequest(HttpServletRequest arg0,
			HttpServletResponse arg1) throws Exception {
		HashMap<String, String> map = new HashMap<String, String>();
		map.put("message", messageService.getMessage());

		ModelAndView mav = new ModelAndView("test", map);
		return mav;
	}
}
}}}

=== JSP implementation ===

We complete our application by showing the rather trivial JSP used to output the message provided by the `MessageService`.

{{{
<html>
<head>
</head>
<body>
<b>A message from message service:</b> <%=request.getAttribute("message")%><br/>
</body>
</html>
}}}

== Running the web application ==

An important feature of Impala's web support is in the fact that you don't need to create a WAR file, or run an ANT build script, to deploy your web application in a development environment. In fact, you don't need to do anything apart from running up a Java main class generated as part of the quickstart application. 

Using CTRL-Shift + T, find the class `StartServer`. Right click, then select Run As ... Java Application.

This will start a Jetty Server and run up a server on port 8080.

The text shown on the console view of Eclipse will look something like this:

{{{
2008-04-01 20:56:10.408::INFO:  Logging to STDERR via org.mortbay.log.StdErrLog
2008-04-01 20:56:10.479::INFO:  jetty-6.1.1
2008-04-01 20:56:10.963:/web:INFO:  Initializing Spring root WebApplicationContext
INFO : BaseImpalaContextLoader - Loading bootstrap context from locations [META-INF/impala-bootstrap.xml, META-INF/impala-web-bootstrap.xml, META-INF/impala-jmx-bootstrap.xml, META-INF/impala-web-listener-bootstrap.xml]
INFO : ScheduledModuleChangeMonitor - Starting org.impalaframework.module.monitor.ScheduledModuleChangeMonitorBean with fixed delay of 2 and interval of 10
INFO : LoadTransitionProcessor - Loading definition root-module
INFO : ScheduledModuleChangeMonitor - Monitoring for changes in module root-module: [file [/Users/philzoio/workspaces/scaffold/main/bin]]
INFO : LoadTransitionProcessor - Loading definition module
INFO : ModuleContributionPostProcessor - Contributing bean messageService from module module
INFO : ScheduledModuleChangeMonitor - Monitoring for changes in module module: [file [/Users/philzoio/workspaces/scaffold/module/bin]]
INFO : LoadTransitionProcessor - Loading definition web
INFO : ScheduledModuleChangeMonitor - Monitoring for changes in module web: [file [/Users/philzoio/workspaces/scaffold/web/bin]]
2008-04-01 20:56:12.133:/web:INFO:  Initializing Spring FrameworkServlet 'web'
INFO : ExternalLoadingImpalaServlet - FrameworkServlet 'web': initialization started
INFO : ExternalLoadingImpalaServlet - FrameworkServlet 'web': initialization completed in 21 ms
2008-04-01 20:56:12.168::INFO:  Started SelectChannelConnector @ 0.0.0.0:8080
DEBUG : ScheduledModuleChangeMonitor - Completed check for modified modules. No modified module contents found
DEBUG : ScheduledModuleChangeMonitor - Completed check for modified modules. No modified module contents found
}}}

You can connect to the server using the URL, assuming of course that you are connecting from the same machine:

{{{
http://localhost:8080/web/message.htm
}}}

http://impala.googlecode.com/svn/wiki/images/scaffold_message.jpg

=== Dynamic application updates ===

Note that Impala is started up to automatically detect changes in your modules, and reload modules in response to these changes. You can play with this mechanism by making changes to classes such as `MessageController` (in the web project) and `MessageServiceImpl` (in the module project).

So how does all this work? Impala is very flexible in supporting different startup configurations. When `ImpalaContextLoaderListener` is invoked on application startup, a bootstrap Spring context is created. This Spring context is not the application's Spring context. Instead, it is an `ApplicationContext` which reflects the Spring wiring for Impala itself.

We'll understand this better when considering the `StartServer` class used to run up Jetty in the previous section.

{{{
public class StartServer {
	public static void main(String[] args) {
		System.setProperty("org.mortbay.log.class", "org.mortbay.log.StdErrLog");
		System.setProperty(WebConstants.BOOTSTRAP_LOCATIONS_RESOURCE_PARAM, "impala-embedded.properties");
		System.setProperty(LocationConstants.WORKSPACE_ROOT_PROPERTY, new File("../").getAbsolutePath());
		StartJetty.main(new String[]{"8080", "../web/context", "/web"});
	}
}}}

The system property `WebConstants.BOOTSTRAP_LOCATIONS_RESOURCE_PARAM` identifies a property file which is used to bootstrap Impala. 

{{{
#This entry is suitable for auto-reloading
bootstrapLocations=bootstrap,web-bootstrap,jmx-bootstrap,web-listener-bootstrap

#This entry is suitable for using the MX4J console
#bootstrapLocations=bootstrap,web-bootstrap,jmx-bootstrap,jmx-adaptor-bootstrap,web-jmx-bootstrap

#This entry allows JMX access via JConsole only
#bootstrapLocations=bootstrap,web-bootstrap,jmx-bootstrap,web-jmx-bootstrap
}}}

The first configuration supports automatic module reloading. Using one of the next two options, you can enable module reloading via JMX (using MX4J on port 8002, or JConsole, respectively).

