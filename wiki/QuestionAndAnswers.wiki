#summary Questions and Answers

=== What does Impala do? ===

Impala allows you to break out your Spring application into individual modules. Each module has it's own Spring application context, which can be started and stopped independently. Each time this happens, a new class loader will typically be used, allowing class changes to be reflected dynamically. Modules are composed in a hierarchy, with interfaces typically defined at higher level modules, and implementation classes tending to be found in lower level modules.

=== What kind of problems does Impala solve? ===

While Spring framework is an excellent piece of software, the fact that it doesn't have any first class support for modules is a real limitation. A large Spring application will consist of thousands of classes and hundreds of bean definitions. These bean definitions will typically be spread across different XML definition files.

Managing these XML definition files becomes a real challenge (and at times a nightmare), especially as the project grows. For example, certain integration tests only require some of the functionality. On the one hand, you don't want to load your entire application for every integration test, but on the other, mixing and matching between different bean definition files across tests is time consuming, error prone, and headache ridden.

Another problem with Spring is the mechanism for varying wirings to support different combinations of configurations within the system. Spring effectively allows this by adding new bean definition files. The definitions which need to be overridden are replaced using new bean definitions with the same names. This mechanism works, but is quite cumbersome, and can result in bean definition bloat.

With applications divided into Impala modules, these problems become much more manageable. Typically, you won't even need to specify application context definition file names when working with Impala. You can compose your application at a higher level using modules. That being said, you can easily vary configurations within modules, either by specifying the Spring configuration files to be used in the module, or by using a flexible bean definition import mechanism provided by Impala.

In addition, Impala provides a number of features aimed at making Spring applications easier to manage and configure. Your operation teams will like Impala!

=== What is the relationship between Impala and TDD? ===

Impala is extremely well suited to test driven development. The interactive test runner provides a powerful mechanism for driving development through [http://impalablog.blogspot.com/2008/04/thoughts-on-integration-testing.html integration tests]. See [GettingStartedPart3 this page] for more details on Impala's test environment.

=== How easy is it go get started with Impala? ===

Very easy. By following the instructions in the [GettingStarted getting started tutorial] you can build and run a modular web application without having to edit a single line. All you need to do is run a few simple commands. 

The only software prerequisites for getting started with Impala are Java (1.5 and above) and ANT (1.6.5 or later is recommended).

Because Impala is based on Spring with unchanged programming model, it will feel very familiar to Spring users. The additional additional knowledge required is a basic understanding of how Impala structures application contexts and class loaders to create a dynamic, modular application environment. All of this means a pretty shallow learning curve for experienced Java developers.

=== What does 'Impala supports modular application development'? ===

This topic is covered in quite a bit of detail in [http://impalablog.blogspot.com/2008/01/modularity-what-is-it-and-why-is-it.html this blog entry].

=== How stable is Impala? ===

For a project approaching its first public release, the Impala code base is very stable. Most of the key features have been in place for several months. Since then, the code base has been through an intense and prolonged round of refactoring. 

Of course, there will be changes between now and 1.0 final. But don't expect an overhaul of the code base - this has already happened. The Impala code base is in fact very well factored - at the time of writing the largest class in the code base is less than 250 lines long, and most classes are less than 100 lines long. 

=== How do  class loaders work in Impala? ===

The mechanisms for specifying the behaviour of classloaders is pluggable. However, the default arrangement is to have a class loader hierarchy which parallels the module hierarchy. Specifically, class loaders for individual modules have visibility of their parent module class loaders, but not that of sibling class loaders. All modules have visibility of the application class loader. 

Loading of third party libraries works identically to regular Java applications - all third party libraries are loaded by the application class loader, which will typically either be the Java class path, or, for web applications, jars in the _WEB-INF/lib_ directory. 

=== Will I run into class loader problems? ===

You'd have to be pretty brave to say never here. However, without making an effort to bend Impala out of shape, you shouldn't run into class loader problems very often, if at all. Impala has been carefully designed to minimise the risk of class loader issues occurring, and make it easy to diagnose these when they do occur. 

=== Does Impala work with Hibernate? ===

Absolutely, see the [http://impalablog.blogspot.com/2008/01/springs-petclinic-sample-impala-style.html Petclinic sample].

=== Does Impala work with other technologies, such as JMX, Quartz, etc. ===

Absolutely. Impala should work with just about any technology that works within Spring itself.

=== What about OSGi? ===

OSGi is an interesting technology that allows for modularity and class version in Java application development. In the problems it tackles, Impala is in many ways quite similar to [http://www.springframework.org/osgi/ Spring Dynamic Modules], which is based on OSGi. While clearly a great technology, it is far from clear to me that OSGi represents the simplest, most practical way to solve the most burning issue which is affecting Spring developers on a day to day basis - the lack of a first class concept of modularity within Spring core, and the resultant difficulties in configuring large, complex applications. OSGi is a great solution for third party class versioning issues, but for me this is much less of a issue than the need for a simple, productive way of achieving modularity. Nevertheless, OSGi is on the Impala roadmap, at least as a area for further investigation. See this [http://impalablog.blogspot.com/2007/11/impala-and-osgi.html Impala Blog entry].

There are those who would have you believe that you cannot have modular applications without OSGi. That is not the case.

=== What about Maven? ===

Unlike many open source projects, Maven is not required to work with Impala. Impala features an ANT-based build system, which can be used in applications. Impala has a simple approach to dependency management, aiming not for full transitive dependency management, but for simple but effective tools for managing dependencies, described in this [http://impalablog.blogspot.com/2007/09/impalas-non-maven-approach-to-simpler.html Impala Blog entry]. 

All this being said, better support for Maven is on the road map. Maven users should be able to work with Impala, using Maven project structure conventions.

=== Why the name Impala? ===

The [http://en.wikipedia.org/wiki/Impala Impala] is an antelope common in the Southern African bushveld and savannah. Impalas are graceful, elegant and agile - qualities worth aspiring to in software development.