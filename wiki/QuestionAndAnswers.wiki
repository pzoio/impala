#summary Questions and Answers

=== What does Impala do? ===

Impala allows you to break out your Spring application into individual modules. Each module has it's own Spring application context, which can be started and stopped independently. Each time this happens, a new class loader will typically be used, allowing class changes to be reflected dynamically. Modules are composed in a hierarchy, with interfaces typically defined at higher level modules, and implementation classes tending to be found in lower level modules.

=== What kind of problems does Impala solve? ===

While Spring framework is an excellent piece of software, the fact that it doesn't have any first class support for modules is a real limitation. A large Spring application will consist of thousands of classes and hundreds of bean definitions. These bean definitions will typically be spread across different XML definition files.

Managing these XML definition files becomes a real challenge (and at times a nightmare), especially as the project grows. For example, certain integration tests only require some of the functionality. On the one hand, you don't want to load your entire application for every integration test, but on the other, mixing and matching between different bean definition files across tests is time consuming, error prone, and headache ridden.

Another problem with Spring is the mechanism for varying wirings to support different combinations of configurations within the system. Spring effectively allows this by adding new bean definition files. The definitions which need to be overridden are replaced using new bean definitions with the same names. This mechanism works, but is quite cumbersome, and can result in bean definition bloat.

With applications divided into Impala modules, these problems become much more manageable. Typically, you won't even need to specify application context definition file names when working with Impala. You can compose your application at a higher level using modules. That being said, you can easily vary configurations within modules, either by specifying the Spring configuration files to be used in the module, or by using a flexible bean definition import mechanism provided by Impala.

In addition, Impala provides a number of features aimed at making Spring applications easier to manage and configure. Your operation teams will like Impala!

=== How easy is it go get started with Impala? ===

How easy do you want it to be? By following the instructions in the [GettingStarted getting started tutorial] you can build and run a modular web application without having to edit a single line. All you need to do is run a few simple commands. 

The only software prerequisites for getting started with Impala are Java (1.5 and above) and ANT (1.6.5 or later is recommended).

Because Impala is based on Spring with unchanged programming model, it will feel very familiar to Spring users. The additional additional knowledge required is a basic understanding of how Impala structures application contexts and class loaders to create a dynamic, modular application environment. All of this means a pretty shallow learning curve for experienced Java developers.

=== Will I run into class loader problems ===

I'd have to be pretty brave to say never here. However, without making an effort to bend Impala out of shape, you shouldn't run into class loader problems very often, if at all. Impala has been carefully designed to minimise the risk of class loader issues occurring, and make it easy to diagnose these when they do occur. 

=== What about OSGi? ===

In the problems it tackles, Impala is in many ways quite similar to Spring Dynamic Modules, which is based on OSGi. While clearly a great technology, it is far from clear to me that OSGi represents the simplest, most practical way to solve the most burning issue which is affecting Spring developers on a day to day basis - the lack of a first class concept of modularity within Spring core, and the resultant difficulties in configuring large, complex applications. OSGi is a great solution for third party class versioning issues, but for me this is much less of a issue than the need for a simple, productive way of achieving modularity. Nevertheless, OSGi is on the Impala roadmap, at least as a area for further investigation. See this [http://impalablog.blogspot.com/2007/11/impala-and-osgi.html Impala Blog entry].

=== What about Maven? ===

Unlike many open source projects, Maven is not required to work with Impala. Impala features an ANT-based build system, which can be used in applications. Impala has a simple approach to dependency management, aiming not for full transitive dependency management, but for simple but effective tools for managing dependencies, described in this [http://impalablog.blogspot.com/2007/09/impalas-non-maven-approach-to-simpler.html Impala Blog entry]. 

All this being said, better support for Maven is on the road map. Maven users should be able to work with Impala, using Maven project structure conventions.

=== Why the name Impala? ===

The [http://en.wikipedia.org/wiki/Impala Impala] is an antelope common in the Southern African bushveld and savannah. Impalas are graceful, elegant and agile - qualities worth aspiring to in software development.