#summary Questions and Answers

=== What does Impala do? ===

Impala allows you to break out your Spring application into individual modules. Each module has it's own Spring application context, which can be started and stopped independently. Each time this happens, a new class loader will typically be used, allowing class changes to be reflected dynamically. Modules are composed in a hierarchy, with interfaces typically defined at higher level modules, and implementation classes tending to be found in lower level modules.

=== What kind of problems does Impala solve? ===

While Spring framework is an excellent piece of software, the fact that it doesn't have any first class support for modules is a real limitation. A large Spring application will consist of thousands of classes and hundreds of bean definitions. These bean definitions will typically be spread across different XML definition files.

Managing these XML definition files becomes a real challenge (and at times a nightmare), especially as the project grows. For example, certain integration tests only require some of the functionality. On the one hand, you don't want to load your entire application for every integration test, but on the other, mixing and matching between different bean definition files across tests is time consuming, error prone, and headache ridden.

Another problem with Spring is the mechanism for varying wirings to support different combinations of configurations within the system. Spring effectively allows this by adding new bean definition files. The definitions which need to be overridden are replaced using new bean definitions with the same names. This mechanism works, but is quite cumbersome, and can result in bean definition bloat.

With applications divided into Impala modules, these problems become much more manageable. Typically, you won't even need to specify application context definition file names when working with Impala. You can compose your application at a higher level using modules. That being said, you can easily vary configurations within modules, either by specifying the Spring configuration files to be used in the module, or by using a flexible bean definition import mechanism provided by Impala.

In addition, Impala provides a number of features aimed at making Spring applications easier to manage and configure. Your ops teams will like Impala!

=== What about OSGi? ===

See this [http://impalablog.blogspot.com/2007/11/impala-and-osgi.html Impala Blog entry].

=== What about Maven? ===

Unlike many open source projects, Maven is not required to work with Impala. Impala features an ANT-based build system, which can be used in applications. Impala has a simple approach to dependency management, aiming not for full transitive dependency management, but for simple but effective tools for managing dependencies, described in this [http://impalablog.blogspot.com/2007/09/impalas-non-maven-approach-to-simpler.html Impala Blog entry]. 

All this being said, better support for Maven is on the road map. Maven users should be able to work with Impala, using Maven project structure conventions.

=== Why the name Impala? ===

The Impala is an animal common in the Southern African bushveld. Impalas are graceful, elegant and agile - qualities worth aspiring to in software development.