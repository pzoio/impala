#summary Understanding Impala's module class loader

The main class loader used in Impala is [http://impala.googlecode.com/svn/trunk/impala/impala-core/src/org/impalaframework/classloader/graph/GraphClassLoader.java GraphClassLoader]
which takes that name because it supports dependencies between modules arranged in a graph, rather than simply a hierarchical or tree-style relationship.

== An example ==

Impala's Graph class loader allows you to express dependencies between modules in the form of a graph. What does this mean.

=== Hierarchical relationships ===

Suppose you have a root module A, which has children B and C. In this case
  * The classes in module A will be visible to classes in modules B and C. 
  * However, the classes in B will not be visible to the classes in C, and vice versa.
  * Also, the classes in B will not be visible to A, and neither will the classes in C be visible to A.
  
What I describe above is a hierarchical relationship, shown below:

http://impala.googlecode.com/svn/wiki/images/modules-hierarchy.png

It allows class loader relationships to be expressed on a parent child basis.

=== Graph-based relationships ===

While this offers a fair amount of flexibility, it is not really sufficient for many real world applications.

Suppose we introduce a new module D, which we would like to be a child of B. However, suppose we would like 
some of the classes that we define in D to also depend on classes in C. With a simple parent to child or hiearchical relationship, 
this is not possible. Instead, we need a graph based relationship, which allows classes in individual modules to have
visibility of classes from multiple dependent modules.

http://impala.googlecode.com/svn/wiki/images/modules-graph.png

== Class loading ==

=== Current Module ===

Whether the class is found will depend on what the *current module* is. So what do we mean by 'current module'. If a module is in the process of being
loaded (for example, if a Spring application context is created), then the current module is the one being loaded. Once the application is running
the current module may take a couple of different meanings. For a web application processing an HTTP request, the current module will initially be the
one to which the request is first directed. However, the request may then involve calls to code defined in other modules.

Impala will change the thread's context class loader so that it reflects the module processing the request. This means that if code in the 
module needs to load classes after the module has loaded, it will be able do so using the same class loader which loaded the code in the first place.

=== Load order ===

Suppose you attempt to load the class named `D` which is contained within the module D. If the current module is D, then Impala 
will first attempt to load the module using the class loader associated with the root module A. 
Failing to find it there, it will look in B, then C, and then in D.

What if we are currently in module B, and attempt to load class `D`. In this case, it will only look in modules A and B.
It will fail to find the class, and throw a `ClassNotFoundException`.

=== Loading third party libraries ===

Our example above only considers loading of a module class. What about third party classes, for example, contained in _WEB-INF/lib_ in a web
application, or in the Java standard libraries?

These classes will be loaded in exactly the same way as in standard standalone or web applications, following the standard class loader
delegation model. For convenience we talk about these classes being present on the system class path.

All that remains to be determined is how the third party class loading mechanism and module class loading mechanisms fit together. 
Which will be searched first?

Actually, this depends on the Impala property 'parent.classloader.first'. If this is set to true, then Impala will first delegate to the system/web application
class loader, only using the module class loader if unable to find the class. If set to false, Impala will first use the module class loader, only then delegating
to the system/application class loader if the class is not found.

So why is this option available, and what are its consequences?

The reason why this option is available is that at times it is necessary to run Impala in environments where module classes are also on the system class path. If class loading was always delegated first to the system class loader, then it would not be possible to reload these modules. In this case, the module class path is searched first, then the system class path.

So when can this cause problems? The 

== Resource loading ==