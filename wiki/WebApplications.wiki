#summary Impala Web Applications

Impala has a lot of features designed to make using and working with web applications as powerful and seamless as possible.
Impala provides flexible deployment options, and supports a large range of scenarios in enabling modular application development.

== Web deployment ==

Impala web applications can be launched in the Eclipse in an embedded Jetty Server. This is powerful, because it means that 
you can do all your web application development without having to run any build scripts. However, war based deployment is also supported.
For more information, see the [GettingStarted tutorial].

== Features ==

Below are some of Impala's web application development features:

  * *modular web applications*: we have the advantages of modularity available for the web tier of our applications just as with any other tier. 
  * *dynamic reloading support for other frameworks*: Impala provides the support not only for Spring MVC-based web applications, but for web applications written using arbitrary Java web frameworks (see the bottom of the page for a caveat on this)
  * *objects held in the `HttpSession` should survive module reloads*, even if the class loader used to load the object originally saved in the session is discarded. See below in this page for more details. 
  
== Initial setup of web application ==

[WebApplicationBootstrapping Bootstrapping web applications]  
  
== Developing multi-module applications ==

1) Impala allows you to arrange your web tier modules in a hierarchy. Just as you have a root module for the application as a whole, 
you also have a root module for the web tier, know as the _web root module_. The _web root module_ contains the servlet context resources,
that is, the resources which will be found below the context path in a deployed application, such as styles, images, jsp files, etc.

2) It is also possible to host resources in the modules themselves.

3) Impala provides web application modularity by allowing each module to be represented by at least one filter or servlet.
It is also possible to have multiple filters or servlets servicing requests, per module.

Note that Impala supports two styles of setting up handlers (filters and servlets) for your aplication:
  * [WebXmlHandlerRegistration Standard _web.xml_ based handler registration]. This is simpler getting started but is much more limited in what you can achieve.
  * [WebModuleBasedHandlerRegistration Module based handler registration]. This requires a little more understanding but offers much greater flexibility when developing multi-module applicaitons.
  
== Other Features ==

=== Servlets and Filters ===

Impala provides a number of servlets and filters which you can use in your application for different purposes.

[ServletsAndFilters Impala servlets and filters]

=== Preserving module session state ===

One of the problems with dynamic reloading of web modules is how to handle session state. The problem is occurs because after a module reload, 
some of the objects held in the session may have been loaded using class loaders that have since been discarded. When the new module
attempts to cast the session object, without any remedial action a `ClassCastException` will be thrown.

Impala fixes this problem by wrapping the `HttpSession` with a `getAttribute` method which does the following:
  * gets the object from the underlying session
  * if an object is found, then the class of that object is inspected to determine whether its classloader is visible to that of the current module's class loader. If so, it is returned as is.
  * if the session object has an incompatible class loader, a check is performed to determine whether the object is serializable. If it is not serializable, then the session attribute is discarded and the event is logged as a warning.
  * if the item is serializable, then an attempt is made to clone the object using serialization. In the process, the state of the object is copied to the new instance, but equally importantly, the new object now has a class loader.
  
It should be noted that this mechanism is not guaranteed to work. For example, serialization may fail if the cloned object's class definition has changed in an incompatible way.

In short, if you ensure that all your session objects use classes which implement `java.io.Serializable`, then you have at least a fighting chance of 
having session state preserved through module reloads. Extra care should be taken if you intend to use in production environments 
dynamic module reloading for modules which hold session state.

A demonstration of the mechanism for preserving session state is available in the Struts module in the [SamplesWebframework web frameworks sample].

=== Thread context class loader ===

The thread context class loader is used to allow Java libraries to application classes through the application classes' class loader, rather than the library classes' class loader. 
Before invoking any module specific servlet or filter, Impala changes the context class loader so that other web frameworks have visibility of the correct module's classes.

For more discussion on this point, see http://impalablog.blogspot.com/2008/10/using-threads-context-class-loader-in.html.

== Caveats ==

There are some important caveats to note regarding Impala's support for integration with web frameworks other than Spring MVC.

1) At this point, the [SamplesWebframework web frameworks sample] demonstrates that tight integration with web frameworks is possible. The basic mechanisms needed for this integration are required:
  * ability to handle the thread context class loader to correctly.
  * the ability to give each module access to it's own Spring root web application context in a way that is transparent to the framework. In the web frameworks sample, for example, the web application context visible to the Struts module is different from the one visible to the Wicket module, even though they are accessed using the same `WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE`.
  * the ability to instantiate an aribitrary servlet within a module, and manage its life cycle correctly.
2) This does not mean that there will not be issues. Each web framework is different, and makes it's own set of assumptions about the environment in which it operates. In a dynamic, multi-module environment, some of these assumptions may be stretched. Without further testing on a per framework basis, it is not possible to know where the problem points lie. 
However, I believe that the problems are likely to be relatively minor and not too difficult to overcome on a case by case basis.
3) Eventually, we can expect that for web frameworks that we decide to properly support, there will be integration projects which resolve these issues and provide a seamless integration with the web framework which will work out of the box.

 





  
