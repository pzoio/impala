#summary Page describing how to set up module configuration

== Basic (Internal) Module Configuration ==

The easiest way to set up a module is through the file _module.properties_. Each module configured in this way will have _module.properties_ sitting
in the root directory of the module's class path. In practice, this means placing _module.properties_ in the module's _resources_ folder.

=== module.properties ===

An example of _module.properties_ is shown below:

{{{
parent=petclinic
type=servlet
context-locations=petclinic-web-context.xml
}}}

This example is taken from the web module definition of the Impala Petclinic application.

*_parent_:* The name of the parent module. This property is required for all modules apart from the root module. 
Remember that each module typically is backed both by its own class loader, and it's own Spring application context.
The relationship between the child
and the parent typically applies both for the class loader and the application context. This means that classes defined in the parent
module are visible to child modules, but not vice versa. Similarly, beans accessible through the parent's `ApplictionContext` are accessible to 
beans in the child's `ApplicationContext`, and not vice versa.

*_type_:* The type of the module. The type of the module governs both the mechanism for loading module definitions, and the mechanism for loading the module, that is
the resources for the module as well as its `ApplicationContext`.

The following types are available out of the box:

||_root:_ || Associated with the root module. This may be backed by the system class or application class loader, or by an Impala custom class loader, depending on the configuration. It will also be backed by a Spring `GenericApplicationContext`.||
||_application:_ || The module type used for most other non-web modules. Typically backed by an Impala custom class loader and a Spring `GenericApplicationContext`.||
||_application_with_beansets:_ || Impala includes a mechanism for overriding bean import definitions in quite a sophisticated way, which can be easily customised via an external configuration. For small to medium-sized modules, this feature is unlikely to be useful.||
||_servlet_:|| This is Impala's main form of web module. It is backed by a `GenericWebApplicationContext` instance, and by an Impala custom class loader. Web modules can be arranged in a hierarchy. However, there can only be one 'root' web module. This module will also contain web application files, such as the _WEB-INF/web.xml_ as well CSS styles, images, etc.||
||_web_root_:|| Similar to the _servlet_ module. There are two main differences. Firstly, _servlet_ modules follow the convention of having Spring configuration files located as class path resources, while _web_root_ modules are found as servlet context resources, that is, relative to the `ServletContext` root directory. The first is consistent with Impala's typical usage, while the latter is closer to the convention of vanilla Spring applications, which use the _servlet-name_ plus _servlet_ suffix convention to locate Spring config files.||
||_web_placeholder_: || This is a special type of module which can be used in some configurations to 'turn off' the functionality that would otherwise be provided by a servlet module. The usage of this type of module is explained in WebConfiguration.||

*_context-locations_:* A comma-separated list of Spring configuration files which make up the bean definitions for the module. Not required -
if not specified the name _%MODULE_NAME%-context.xml_ is assumed.

The properties listed above are the most commonly used properties. It should be noted that more esoteric module types may use other properties. An example
is the property _root-project-names_, which can be used for a _root_ module to indicate that this should consist of the contents of multiple projects. 
For most use cases, the module types and _module.properties_ names described above should be sufficient.

== External Configuration ==

While the simplest and most reusable configuration is the internal configuration, there are sometime times where you may wish to externally override
module configurations. In this case, the module configuration can be expressed for the application as a whole by simply listing the names of the modules.
An example is the module configuration for the [[SampleWebframeworks web frameworks sample]]:

{{{
<parent>
	<names>
	webframeworks
	webframeworks-service
	webframeworks-web
	webframeworks-struts
	webframeworks-wicket
	webframeworks-tapestry5
	</names>
</parent>
}}} 

There are times, however, when you won't simply wish to reuse the default internal module configuration in its entirety.

For example, suppose one of your modules consist of a set of JMX Spring beans which you may wish to use in some
environments but not others. One approach to this problem would be to split these beans into a separate module. However, there are times where this approach
may seem like overkill, and if followed through, could lead to an explosion in the number of modules. 

In plain Spring applications, functionality is often turned on or off by the inclusion or exclusion of Spring application context files. This same approach can 
be applied within a module, by externally overriding the _context-locations_ property.

An example of this is shown below.

== Internal Details ==

An Impala module is represented by an instance of `ModuleDefinition`.

It's pretty straightforward to add new module types. You will need to override the `typeReaders` bean in the Impala Spring configuration, as well as the 
`moduleLoaders` property of the `moduleLoaderRegistry` Impala Spring bean.